# 基本注解

- @Deprecated                     表示某个程序元素，如类，方法等已过时

- @Override                          该注解只能用于方法，限定必须覆盖父类中的方法

- @SuppressWarnings        该注解用于抑制警告信息的出现，即不允许出现警告信息

- @FunctionalInterfase       用于指定某个接口必须是函数式接口

# 元注解

- @Target(value=使用范围)                      限制注解的使用范围

- @Retention(value=保存策略值)            说明注解的保存范围

- @Documented                                       用于指定被修饰的注解可被javadoc.exe工具提取成文档

- @Inherited                                              用于描述一个父类的注解可以被子类继承

- @Repeatable                                          用于开发重复注解

# 自定义注解

```java
// 使用 @interface 就相当于继承了 java.lang.annotation.Annotation接口
// 并别不能再去继承别的 类 或者 接口
[public] @interface 注解名 {
    数据类型 成员变量名 () [default 初始值];
    ...
}
```

# 注解原理

InvocationHandler AnnotationInvocationHandler 

首先，我们通过键值对的形式可以为注解属性赋值，像这样：`@Hello（value = "hello"）`。

接着，你用注解修饰某个元素，编译器将在编译期扫描每个类或者方法上的注解，会做一个基本的检查，你的这个注解是否允许作用在当前位置，最后会将注解信息写入元素的属性表。

然后，当你进行反射的时候，虚拟机将所有生命周期在 RUNTIME 的注解取出来放到一个 map 中，并创建一个 AnnotationInvocationHandler 实例，把这个 map 传递给它。

最后，虚拟机将采用 JDK 动态代理机制生成一个目标注解的代理类，并初始化好处理器。

那么这样，一个注解的实例就创建出来了，它本质上就是一个代理类，你应当去理解好 AnnotationInvocationHandler 中 invoke 方法的实现逻辑，这是核心。一句话概括就是，通过方法名返回注解属性值。
